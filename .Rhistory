}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2025-11-01 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
JAOPuTo_get <- function(dataset,
endpoint,
start,
end,
skip = 0L,
take = 4000L) {
base_url <- "https://publicationtool.jao.eu"
# ---- tijdsinterval voorbereiden (naar UTC) ----
start_utc <- as.POSIXct(start, tz = "UTC")
end_utc   <- as.POSIXct(end,   tz = "UTC")
if (end_utc < start_utc) {
stop("JAOPuTo_get(): 'end' ligt vóór 'start'.", call. = FALSE)
}
# helper: POSIXct -> ISO 8601 UTC
to_utc_iso <- function(x) {
format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
}
# dagenreeks
days <- seq(as.Date(start_utc), as.Date(end_utc), by = "1 day")
# slashes opschonen zodat we geen dubbele // krijgen
dataset_clean  <- sub("/+$", "", dataset)
endpoint_clean <- sub("^/+", "", endpoint)
results   <- list()
meta_list <- list()
for (i in seq_along(days)) {
# begin van de chunk
if (i == 1) {
day_start <- start_utc
} else {
day_start <- as.POSIXct(days[i], tz = "UTC")
}
# einde van de chunk
if (i == length(days)) {
day_end <- end_utc
} else {
day_end <- as.POSIXct(days[i + 1], tz = "UTC") - 1
}
query <- list(
fromUtc = to_utc_iso(day_start),
toUtc   = to_utc_iso(day_end),
skip    = skip,
take    = take
)
url <- paste(base_url, dataset_clean, endpoint_clean, sep = "/")
resp <- httr::GET(url, query = query)
if (httr::http_error(resp)) {
stop(
"JAOPuTo_get(): HTTP error (",
httr::status_code(resp), ") voor chunk ",
i, "/", length(days), ".",
call. = FALSE
)
}
txt    <- httr::content(resp, as = "text", encoding = "UTF-8")
parsed <- jsonlite::fromJSON(txt, simplifyDataFrame = TRUE)
if ("data" %in% names(parsed)) {
dat <- tibble::as_tibble(parsed$data)
meta_list[[length(meta_list) + 1L]] <- parsed[setdiff(names(parsed), "data")]
} else {
dat <- tibble::as_tibble(parsed)
meta_list[[length(meta_list) + 1L]] <- NULL
}
if (nrow(dat) > 0) {
results[[length(results) + 1L]] <- dat
}
}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
JAOPuTo_get <- function(dataset,
endpoint,
start,
end,
skip = 0L,
take = 4000L) {
base_url <- "https://publicationtool.jao.eu"
# ---- tijdsinterval voorbereiden (naar UTC) ----
start_utc <- as.POSIXct(start, tz = "UTC")
end_utc   <- as.POSIXct(end,   tz = "UTC")
if (end_utc < start_utc) {
stop("JAOPuTo_get(): 'end' ligt vóór 'start'.", call. = FALSE)
}
# helper: POSIXct -> ISO 8601 UTC
to_utc_iso <- function(x) {
format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
}
# dagenreeks
days <- seq(as.Date(start_utc), as.Date(end_utc), by = "1 day")
# slashes opschonen zodat we geen dubbele // krijgen
dataset_clean  <- sub("/+$", "", dataset)
endpoint_clean <- sub("^/+", "", endpoint)
results   <- list()
meta_list <- list()
for (i in seq_along(days)) {
# begin van de chunk
if (i == 1) {
day_start <- start_utc
} else {
day_start <- as.POSIXct(days[i], tz = "UTC")
}
# einde van de chunk
if (i == length(days)) {
day_end <- end_utc
} else {
day_end <- as.POSIXct(days[i + 1], tz = "UTC") - 1
}
query <- list(
fromUtc = to_utc_iso(day_start),
toUtc   = to_utc_iso(day_end),
skip    = skip,
take    = take
)
url <- paste(base_url, dataset_clean, endpoint_clean, sep = "/")
resp <- httr::GET(url, query = query)
if (httr::http_error(resp)) {
stop(
"JAOPuTo_get(): HTTP error (",
httr::status_code(resp), ") voor chunk ",
i, "/", length(days), ".",
call. = FALSE
)
}
txt    <- httr::content(resp, as = "text", encoding = "UTF-8")
parsed <- jsonlite::fromJSON(txt, simplifyDataFrame = TRUE)
if ("data" %in% names(parsed)) {
dat <- tibble::as_tibble(parsed$data)
meta_list[[length(meta_list) + 1L]] <- parsed[setdiff(names(parsed), "data")]
} else {
dat <- tibble::as_tibble(parsed)
meta_list[[length(meta_list) + 1L]] <- NULL
}
if (nrow(dat) > 0) {
results[[length(results) + 1L]] <- dat
}
}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2025-11-01 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2025-10-01 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2022-06-09 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
JAOPuTo_get <- function(dataset,
endpoint,
start,
end,
skip = 0L,
take = 4000L) {
base_url <- "https://publicationtool.jao.eu"
start_utc <- as.POSIXct(start, tz = "UTC")
end_utc   <- as.POSIXct(end,   tz = "UTC")
if (end_utc < start_utc) {
stop("JAOPuTo_get(): 'end' lies before 'start'.", call. = FALSE)
}
to_utc_iso <- function(x) {
format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
}
days <- seq(as.Date(start_utc), as.Date(end_utc), by = "2 day")
dataset_clean  <- sub("/+$", "", dataset)
endpoint_clean <- sub("^/+", "", endpoint)
results   <- list()
meta_list <- list()
for (i in seq_along(days)) {
if (i == 1) {
day_start <- start_utc
} else {
day_start <- as.POSIXct(days[i], tz = "UTC")
}
if (i == length(days)) {
day_end <- end_utc
} else {
day_end <- as.POSIXct(days[i + 1], tz = "UTC") - 1
}
query <- list(
fromUtc = to_utc_iso(day_start),
toUtc   = to_utc_iso(day_end),
skip    = skip,
take    = take
)
url <- paste(base_url, dataset_clean, endpoint_clean, sep = "/")
resp <- httr::GET(url, query = query)
if (httr::http_error(resp)) {
stop(
"JAOPuTo_get(): HTTP error (",
httr::status_code(resp), ") for chunk ",
i, "/", length(days), ".",
call. = FALSE
)
}
txt    <- httr::content(resp, as = "text", encoding = "UTF-8")
parsed <- jsonlite::fromJSON(txt, simplifyDataFrame = TRUE)
if ("data" %in% names(parsed)) {
dat <- tibble::as_tibble(parsed$data)
meta_list[[length(meta_list) + 1L]] <- parsed[setdiff(names(parsed), "data")]
} else {
dat <- tibble::as_tibble(parsed)
meta_list[[length(meta_list) + 1L]] <- NULL
}
if (nrow(dat) > 0) {
results[[length(results) + 1L]] <- dat
}
}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
JAOPuTo_get <- function(dataset,
endpoint,
start,
end,
skip = 0L,
take = 4000L,
rate_limit_per_minute = 100) {
base_url <- "https://publicationtool.jao.eu"
sleep_time <- if (is.finite(rate_limit_per_minute) &&
rate_limit_per_minute > 0) {
60 / rate_limit_per_minute
} else {
0
}
start_utc <- as.POSIXct(start, tz = "UTC")
end_utc   <- as.POSIXct(end,   tz = "UTC")
if (end_utc < start_utc) {
stop("JAOPuTo_get(): 'end' ligt vóór 'start'.", call. = FALSE)
}
to_utc_iso <- function(x) {
format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
}
days <- seq(as.Date(start_utc), as.Date(end_utc), by = "1 day")
dataset_clean  <- sub("/+$", "", dataset)
endpoint_clean <- sub("^/+", "", endpoint)
results   <- list()
meta_list <- list()
for (i in seq_along(days)) {
if (i == 1) {
day_start <- start_utc
} else {
day_start <- as.POSIXct(days[i], tz = "UTC")
}
if (i == length(days)) {
day_end <- end_utc
} else {
day_end <- as.POSIXct(days[i + 1], tz = "UTC") - 1
}
query <- list(
fromUtc = to_utc_iso(day_start),
toUtc   = to_utc_iso(day_end),
skip    = skip,
take    = take
)
url <- paste(base_url, dataset_clean, endpoint_clean, sep = "/")
resp <- httr::GET(url, query = query)
if (httr::http_error(resp)) {
stop(
"JAOPuTo_get(): HTTP error (",
httr::status_code(resp), ") voor chunk ",
i, "/", length(days), ".",
call. = FALSE
)
}
txt    <- httr::content(resp, as = "text", encoding = "UTF-8")
parsed <- jsonlite::fromJSON(txt, simplifyDataFrame = TRUE)
if ("data" %in% names(parsed)) {
dat <- tibble::as_tibble(parsed$data)
meta_list[[length(meta_list) + 1L]] <-
parsed[setdiff(names(parsed), "data")]
} else {
dat <- tibble::as_tibble(parsed)
meta_list[[length(meta_list) + 1L]] <- NULL
}
if (nrow(dat) > 0) {
results[[length(results) + 1L]] <- dat
}
if (sleep_time > 0 && i < length(days)) {
Sys.sleep(sleep_time)
}
}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
JAOPuTo_get <- function(dataset,
endpoint,
start,
end,
skip = 0L,
take = 4000L,
rate_limit_per_minute = 100) {
base_url <- "https://publicationtool.jao.eu"
sleep_time <- if (is.finite(rate_limit_per_minute) &&
rate_limit_per_minute > 0) {
60 / rate_limit_per_minute
} else {
0
}
start_utc <- as.POSIXct(start, tz = "UTC")
end_utc   <- as.POSIXct(end,   tz = "UTC")
if (end_utc < start_utc) {
stop("JAOPuTo_get(): 'end' ligt vóór 'start'.", call. = FALSE)
}
to_utc_iso <- function(x) {
format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
}
days <- seq(as.Date(start_utc), as.Date(end_utc), by = "1 day")
dataset_clean  <- sub("/+$", "", dataset)
endpoint_clean <- sub("^/+", "", endpoint)
results   <- list()
meta_list <- list()
for (i in seq_along(days)) {
if (i == 1) {
day_start <- start_utc
} else {
day_start <- as.POSIXct(days[i], tz = "UTC")
}
if (i == length(days)) {
day_end <- end_utc
} else {
day_end <- as.POSIXct(days[i + 1], tz = "UTC") - 1
}
query <- list(
fromUtc = to_utc_iso(day_start),
toUtc   = to_utc_iso(day_end),
skip    = skip,
take    = take
)
url <- paste(base_url, dataset_clean, endpoint_clean, sep = "/")
resp <- httr::GET(url, query = query)
if (httr::http_error(resp)) {
stop(
"JAOPuTo_get(): HTTP error (",
httr::status_code(resp), ") voor chunk ",
i, "/", length(days), ".",
call. = FALSE
)
}
txt    <- httr::content(resp, as = "text", encoding = "UTF-8")
parsed <- jsonlite::fromJSON(txt, simplifyDataFrame = TRUE)
if ("data" %in% names(parsed)) {
dat <- tibble::as_tibble(parsed$data)
meta_list[[length(meta_list) + 1L]] <-
parsed[setdiff(names(parsed), "data")]
} else {
dat <- tibble::as_tibble(parsed)
meta_list[[length(meta_list) + 1L]] <- NULL
}
if (nrow(dat) > 0) {
results[[length(results) + 1L]] <- dat
}
if (sleep_time > 0 && i < length(days)) {
Sys.sleep(sleep_time)
}
}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2022-06-09 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
#' @param start
#' @param end
#' @param skip
#' @param take
#' @param rate_limit_per_minute
#'
#' @return
#' @export
#'
#' @examples
JAOPuTo_get <- function(dataset,
endpoint,
start,
end,
skip = 0L,
take = 4000L,
rate_limit_per_minute = 100) {
base_url <- "https://publicationtool.jao.eu"
sleep_time <- if (is.finite(rate_limit_per_minute) &&
rate_limit_per_minute > 0) {
60 / rate_limit_per_minute
} else {
0
}
start_utc <- as.POSIXct(start, tz = "UTC")
end_utc   <- as.POSIXct(end,   tz = "UTC")
if (end_utc < start_utc) {
stop("JAOPuTo_get(): 'end' ligt vóór 'start'.", call. = FALSE)
}
to_utc_iso <- function(x) {
format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
}
days <- seq(as.Date(start_utc), as.Date(end_utc), by = "1 day")
dataset_clean  <- sub("/+$", "", dataset)
endpoint_clean <- sub("^/+", "", endpoint)
results   <- list()
meta_list <- list()
for (i in seq_along(days)) {
if (i == 1) {
day_start <- start_utc
} else {
day_start <- as.POSIXct(days[i], tz = "UTC")
}
if (i == length(days)) {
day_end <- end_utc
} else {
day_end <- as.POSIXct(days[i + 1], tz = "UTC") - 1
}
query <- list(
fromUtc = to_utc_iso(day_start),
toUtc   = to_utc_iso(day_end),
skip    = skip,
take    = take
)
url <- paste(base_url, dataset_clean, endpoint_clean, sep = "/")
resp <- httr::GET(url, query = query)
if (httr::http_error(resp)) {
stop(
"JAOPuTo_get(): HTTP error (",
httr::status_code(resp), ") voor chunk ",
i, "/", length(days), ".",
call. = FALSE
)
}
txt    <- httr::content(resp, as = "text", encoding = "UTF-8")
parsed <- jsonlite::fromJSON(txt, simplifyDataFrame = TRUE)
if ("data" %in% names(parsed)) {
dat <- tibble::as_tibble(parsed$data)
meta_list[[length(meta_list) + 1L]] <-
parsed[setdiff(names(parsed), "data")]
} else {
dat <- tibble::as_tibble(parsed)
meta_list[[length(meta_list) + 1L]] <- NULL
}
if (nrow(dat) > 0) {
results[[length(results) + 1L]] <- dat
}
if (sleep_time > 0 && i < length(days)) {
Sys.sleep(sleep_time)
}
}
if (length(results) == 0) {
out <- tibble::tibble()
} else {
out <- tibble::as_tibble(do.call(rbind, results))
}
attr(out, "meta") <- meta_list
out
}
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2025-01-01 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
range(np$dateTimeUtc)
np <- JAOPuTo_get("core", "api/data/maxNetPos",
as.POSIXct("2024-01-01 00:00", "CET"),
as.POSIXct("2025-11-02 23:00", "CET"))
devtools::check()
devtools::document()
devtools::check()
usethis::use_gpl3_license("Nico Schoutteet")
usethis::use_gpl3_license("Nico Schoutteet")
devtools::document()
devtools::document()
usethis::use_gpl3_license("Nico Schoutteet")
devtools::document()
usethis::use_mit_license("Nico Schoutteet")
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::build_readme()
